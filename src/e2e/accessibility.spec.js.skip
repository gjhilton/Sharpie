import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';
import {
	selectGameMode,
	navigateToCatalogue,
	navigateToFeedback,
} from '../config/playwright/helpers/test-helpers.js';

test.describe('Accessibility', () => {
	test('menu screen should not have accessibility violations', async ({
		page,
	}) => {
		await page.goto('/');

		const accessibilityScanResults = await new AxeBuilder({ page }).analyze();

		expect(accessibilityScanResults.violations).toEqual([]);
	});

	test('game screen should not have accessibility violations', async ({
		page,
	}) => {
		await selectGameMode(page, 'all');

		const accessibilityScanResults = await new AxeBuilder({ page }).analyze();

		expect(accessibilityScanResults.violations).toEqual([]);
	});

	test('catalogue screen should not have accessibility violations', async ({
		page,
	}) => {
		await navigateToCatalogue(page);

		const accessibilityScanResults = await new AxeBuilder({ page }).analyze();

		expect(accessibilityScanResults.violations).toEqual([]);
	});

	test('feedback screen should not have accessibility violations', async ({
		page,
	}) => {
		await navigateToFeedback(page);

		const accessibilityScanResults = await new AxeBuilder({ page }).analyze();

		expect(accessibilityScanResults.violations).toEqual([]);
	});

	test('should have proper heading hierarchy', async ({ page }) => {
		await page.goto('/');

		// Should have h1
		const h1 = page.locator('h1');
		await expect(h1.first()).toBeVisible();

		// Check heading order (h1 should come before h2, etc.)
		const headings = await page.locator('h1, h2, h3, h4, h5, h6').all();
		const headingLevels = await Promise.all(
			headings.map((h) => h.evaluate((el) => parseInt(el.tagName[1]))),
		);

		// First heading should be h1
		expect(headingLevels[0]).toBe(1);
	});

	test('images should have alt text', async ({ page }) => {
		await page.goto('/');

		const images = await page.locator('img').all();

		for (const img of images) {
			const alt = await img.getAttribute('alt');
			expect(alt).toBeTruthy();
		}
	});

	test('interactive elements should be keyboard accessible', async ({
		page,
	}) => {
		await page.goto('/');

		// Tab through interactive elements
		const focusableElements = [];
		for (let i = 0; i < 10; i++) {
			await page.keyboard.press('Tab');
			const tagName = await page.evaluate(() =>
				document.activeElement.tagName,
			);
			focusableElements.push(tagName);
		}

		// Should have found buttons and links
		expect(focusableElements).toContain('BUTTON');
		expect(focusableElements.some((tag) => ['A', 'BUTTON'].includes(tag))).toBe(
			true,
		);
	});

	test('links should have discernible text', async ({ page }) => {
		await page.goto('/');

		const links = await page.locator('a').all();

		for (const link of links) {
			const text = await link.textContent();
			const ariaLabel = await link.getAttribute('aria-label');

			// Link should have either visible text or aria-label
			expect(text || ariaLabel).toBeTruthy();
		}
	});

	test('form inputs should have labels', async ({ page }) => {
		await navigateToFeedback(page);

		const inputs = await page.locator('input, textarea').all();

		for (const input of inputs) {
			const id = await input.getAttribute('id');
			if (id) {
				const label = page.locator(`label[for="${id}"]`);
				await expect(label).toBeVisible();
			}
		}
	});

	test('buttons should have accessible names', async ({ page }) => {
		await page.goto('/');

		const buttons = await page.locator('button').all();

		for (const button of buttons) {
			const text = await button.textContent();
			const ariaLabel = await button.getAttribute('aria-label');

			// Button should have either text or aria-label
			expect(text || ariaLabel).toBeTruthy();
		}
	});

	test('color contrast should be sufficient', async ({ page }) => {
		await page.goto('/');

		// Run axe test specifically for color contrast
		const accessibilityScanResults = await new AxeBuilder({ page })
			.withTags(['wcag2aa', 'wcag21aa'])
			.analyze();

		const contrastViolations = accessibilityScanResults.violations.filter(
			(v) => v.id.includes('color-contrast'),
		);

		expect(contrastViolations).toEqual([]);
	});

	test('page should have a language attribute', async ({ page }) => {
		await page.goto('/');

		const lang = await page.getAttribute('html', 'lang');
		expect(lang).toBeTruthy();
	});

	test('skip links or landmarks should exist for navigation', async ({
		page,
	}) => {
		await page.goto('/');

		// Check for skip link or main landmark
		const skipLink = page.locator('a[href^="#"]').first();
		const main = page.locator('main, [role="main"]');

		const hasSkipLink = (await skipLink.count()) > 0;
		const hasMain = (await main.count()) > 0;

		// Should have either skip link or main landmark
		expect(hasSkipLink || hasMain).toBe(true);
	});

	test('focus should be visible', async ({ page }) => {
		await page.goto('/');

		// Focus on a button
		const button = page.getByRole('button').first();
		await button.focus();

		// Get computed styles
		const outlineWidth = await button.evaluate(
			(el) => window.getComputedStyle(el).outlineWidth,
		);
		const outlineStyle = await button.evaluate(
			(el) => window.getComputedStyle(el).outlineStyle,
		);

		// Should have some kind of outline (browsers have defaults)
		expect(outlineStyle).not.toBe('none');
	});
});
